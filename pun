#!/bin/bash
#
# pun - Pacman Update Notifier
# 
# v0.6 / 2015.06.19
#
# © 2015 Bernd Busse, Daniel Jankowski
# Licensed under the LGPLv3

LAST_MAIL_SAVE=/var/lib/pun/mail_save.dat
LAST_CHECK_SAVE=/var/lib/pun/check_save.dat

MAIL_FILE=/var/lib/pun/sendmail.txt
CONFIG_FILE=/etc/pun.conf
MAIL_ADDR="${USER}@localhost"

# for telegram(should be read from config...)
# TODO: add telegram to config file
_telegram_public_key=''
_telegram_destination=''
_use_telegram=0


function print_usage() {
    echo "Usage: $0 [OPTIONS]"
}

function print_version() {
    echo "pun - Pacman Update Notifier"
    echo "Version v0.6 - © Bernd Busse, Daniel Jankowski"
}

function print_help() {
    print_version
    echo ""
    print_usage
    echo ""
    echo "    -h ; --help             Show this help message"
    echo "    -c ; --config CONFIG    Use config file CONFIG"
    echo "    -p                      Force to use pacman"
    echo "    -d                      Send no mail"
    echo "    -v                      Force output of updates list"
    echo "    -t                      Send update-list via telegram"
    echo ""
    echo "If package-query is installed, it will be used by default."
    echo "Force use of pacman with the -p switch (no aur)."
}

function exit_option_err() {
    echo "Error: Wrong option for '${1}': ${2}"
    exit 1
}

function print_log() {
    if [[ $_conf_output_mode != "none" && $_conf_output_mode != "cron" ]]; then
        echo "$1"
    fi
}

function print_mail() {
    echo "$1" >> ${MAIL_FILE}
}

function print_pkglist() {
    _old_ifs=$IFS
    while IFS= read -r pkg; do
        echo "    :: $pkg"
    done < <(echo -e "${1}")
    IFS=$_old_ifs
}

function send_mail() {
    # write to temporary mail file
    if [[ -e "$MAIL_FILE" ]]; then
        rm -rf "$MAIL_FILE"
    fi
    
    echo "Last update: $last_upd." >> $MAIL_FILE
    echo "You have $num_pkg updates:" >> $MAIL_FILE
    print_pkglist "$pkg_list" >> $MAIL_FILE
 
    if (( $_conf_send_mail == 1 )); then
        # send mail
        mail -s "$( date +"%Y-%m-%d %H:%M" ) - $( hostname ) has ${num_pkg} new Update(s)" $MAIL_ADDR < "${MAIL_FILE}"
    fi
    if [[ $_conf_output_mode == "cron" ]]; then
        # cron mode output
        cat ${MAIL_FILE}
    fi
}

# TODO: get telegram working; bug in telegram-cli with send_text
function send_telegram() {
    # write to temporary mail file
    if [[ -e "$MAIL_FILE" ]]; then
        rm -rf "$MAIL_FILE"
    fi
    
    echo "Last update: $last_upd." >> $MAIL_FILE
    echo "You have $num_pkg updates:"  >> $MAIL_FILE
    echo "mail" "$pkg_list" >> $MAIL_FILE
   
    # send via telegram
    telegram-cli -W -C -D -k ${_telegram_public_key} -e "send_text ${_telegram_destination} ${MAIL_FILE}" 
}

function parse_config() {
    _old_ifs=$IFS
    while IFS= read -r line; do
        if [[ $line == "#"* ]]; then
            continue
        elif [[ $line == "" || $line == " "* ]]; then
            continue
        fi

        _name="$( echo "${line}" | sed -re 's/=.*$//' )"
        _setting=$( echo "${line}" | sed -re 's/^.*=(\S+)\s.*$/\1/g' )
   
        # check name and setting
        case ${_name} in
            "FORCE_PACMAN")
                case "${_setting}" in
                    "0"|"1")
                        _conf_pacman_forced=${_conf_pacman_forced:-${_setting}} ;;
                    *)
                        exit_option_err ${_name} ${_setting} ;;
                esac ;;
            "OUTPUT")
                case ${_setting} in
                    "cron"|"verbose"|"none"|"log")
                        _conf_output_mode=${_conf_output_mode:-${_setting}} ;;
                    *)
                        exit_option_err ${_name} ${_setting} ;;
                esac ;;
            "MAIL")
                case "${_setting}" in
                    "0"|"1")
                        _conf_send_mail=${_conf_send_mail:-${_setting}} ;;
                    *)
                        exit_option_err ${_name} ${_setting} ;;
                esac ;;
            *)
                echo "ERROR: cannot parse option ${_name}"
                exit 1 ;;
        esac
    done < <(echo "${1}")
    IFS=$_old_ifs
}


# parse command line options
while [[ -n $1 ]]; do
    case ${1} in
        "-h"|"--help")
            print_help
            exit 0 ;;
        "-c"|"--config")
            if [[ -e "${2}" ]]; then
                CONFIG_FILE="${2}"
            else
                print "Can't open config file '${2}'"
                exit 1
            fi
            shift 2 ;;
        "-p")
            _conf_pacman_forced=1
            shift ;;
        "-v")
            _conf_output_mode="verbose"
            shift ;;
        "-d")
            _conf_send_mail=0
            shift ;;
        "-c")
            _conf_output_mode="cron"
            shift ;;
        "-q")
            _conf_output_mode="none"
            shift ;;
        "-t")
            _use_telegram=1
            shift ;;
        *)
            echo "Unknown option: $1"
            print_usage
            exit 1 ;;
    esac
done

# get config
if [[ -e "$CONFIG_FILE" ]]; then
    conf="$( cat $CONFIG_FILE )"
    parse_config "$conf"
fi

# set defaults for unset configs
_conf_pacman_forced=${_conf_pacman_forced:-0}
_conf_output_mode=${_conf_output_mode:-"log"}
_conf_send_mail=${_conf_send_mail:-1}
_conf_send_telegram=${_conf_send_telegram:-1}

# create temporary directory if not exists
if [[ ! -d "/var/lib/pun" ]]; then
    mkdir /var/lib/pun
fi

# check for pacman and package-query
if [[ -x "$( which pacman 2> /dev/null )" ]]; then
    _pacman="$( which pacman )"
else
    echo "Error: cannot find pacman. Your system is weird!"
    exit 1
fi

if [[ -x "$( which package-query 2> /dev/null )" ]] && (( $_conf_pacman_forced != 1 )); then
    _query="$( which package-query )"
    list_cmd="$_query -QAu"
else
    list_cmd="$_pacman --color never -Qu"
fi

# update package database
$_pacman -Sy >& /dev/null
if (( $? != 0 )); then
    echo "Error: cannot update database (try with sudo?)"
    exit 1
fi

# get updatelist
pkg_list="$( $list_cmd 2> /dev/null )"
if (( $? != 0 )); then
    echo "Error: cannot fetch update list"
    exit 1
fi

num_pkg="$( echo -e "${pkg_list}" | wc -l )"
last_upd="$( grep -e 'starting full system upgrade' /var/log/pacman.log | sed -re 's/^\[([0-9]{4}-[0-9]{2}-[0-9]{2}\s[0-9]{2}:[0-9]{2})\]\s.*$/\1/g' | tail -n -1 )"

# print message
print_log "Last update: $last_upd"

if (( $num_pkg == 0 )); then
    # system is up to date => don't send a mail
    print_log "System is up to date."
else
    if [[ $_conf_output_mode == "verbose" ]]; then
        print_log "You have $num_pkg updates:"
        print_pkglist "$pkg_list"
    else
        print_log "You have $num_pkg updates."
    fi

    if (( $_conf_send_mail == 1 || $_conf_send_telegram == 1 )) || [[ $_conf_output_mode == "cron" ]]; then
        # read last_mail date from file
        if [[ -e "$LAST_MAIL_SAVE" ]]; then
            mail_sec=$( date -d "$( cat "$LAST_MAIL_SAVE" )" +%s )
        fi

        # read package numer of last check from file
        if [[ -e "$LAST_CHECK_SAVE" ]]; then
            last_num="$( cat "$LAST_CHECK_SAVE" )"
        fi

        update_sec=$( date -d "$last_upd" +%s )

        # should we send a mail?
        if (( ${mail_sec:-0} < $update_sec || ${last_num:-0} < $num_pkg )); then
            # mail not yet send OR new updates available
            print_log "Sending mail..."
            
            # send mail
            send_mail

            date +"%Y-%m-%d %H:%M" > $LAST_MAIL_SAVE
            echo "$num_pkg" > $LAST_CHECK_SAVE
        else
            # no new updates
            print_log "No new updates since last mail."
        fi
    fi
fi
