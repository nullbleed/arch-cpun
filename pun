#!/bin/bash
#
# pun - Pacman Update Notifier
# 
# v0.5 / 2015.06.19
#
# © 2015 Bernd Busse, Daniel Jankowski
# Licensed under the LGPLv3

LAST_MAIL_SAVE=/var/lib/pun/mail_save.dat
LAST_CHECK_SAVE=/var/lib/pun/check_save.dat

MAIL_FILE=/var/lib/pun/sendmail.txt
CONFIG_FILE=/etc/pun.conf
#CONFIG_FILE=./pun.conf

# for telegram(should be read from config...)
# TODO: add telegram to config file
_telegram_public_key=''
_telegram_destination=''


function print_usage() {
    echo "Usage: $0 [OPTIONS]"
}

function print_version() {
    echo "pun - Pacman Update Notifier"
    echo "Version v0.4 - © Bernd Busse, Daniel Jankowski"
}

function print_help() {
    print_version
    echo ""
    print_usage
    echo ""
    echo "    -h ; --help             Show this help message"
    echo "    -c ; --config CONFIG    Use config file CONFIG"
    echo "    -p                      Force to use pacman"
    echo "    -d                      Send no mail"
    echo "    -v                      Force output of updates list"
    echo ""
    echo "If package-query is installed, it will be used by default."
    echo "Force use of pacman with the -p switch (no aur)."
}

function exit_option_err() {
    echo "Error: Wrong option for '${1}': ${2}"
    exit 1
}

function print_log() {
    if (( $_conf_cron_output == 0 )); then
        echo "$1"
    fi
}

function print_mail() {
    if (( $_conf_cron_output == 0 )); then
        echo "$1" >> $MAIL_FILE
    else
        echo "$1"
    fi
}

function print_pkglist() {
    _old_ifs=$IFS
    if (( $_conf_cron_output == 0 )); then
        if [[ ${1} == "mail" ]]; then
            echo -e "$2" | while IFS= read -r pkg; do
                echo "    :: $pkg" >> $MAIL_FILE
            done
        elif [[ ${1} == "log" ]]; then
            echo -e "$2" | while IFS= read -r pkg; do
                echo "    :: $pkg"
            done
        fi
    elif (( $_conf_cron_output != 0 )) && [[ ${1} == "mail" ]]; then
        echo -e "$2" | while IFS= read -r pkg; do
            echo "    :: $pkg"
        done
    fi
    IFS=$_old_ifs
}

function send_mail() {
    # write to temporary mail file
    if [[ -e "$MAIL_FILE" ]]; then
        rm -rf "$MAIL_FILE"
    fi
    
    echo "Last update: $last_upd." >> $MAIL_FILE
    echo "You have $num_pkg updates:"  >> $MAIL_FILE
    echo "mail" "$pkg_list" >> $MAIL_FILE
 
    case "${_conf_mail}" in
        "1")
            # send mail
            mail -s "$( date +"%Y-%m-%d %H:%M" ) - $( hostname ) has ${num_pkg} new Update(s)" $MAIL_ADRESS < "${MAIL_FILE}"
            ;;
        "2")
            # send mail
            mail -s "$( date +"%Y-%m-%d %H:%M" ) - $( hostname ) has ${num_pkg} new Update(s)" $MAIL_ADRESS < "${MAIL_FILE}"
            ;;
        *)
            echo "Wrong option"
            ;;
    esac
}

# TODO: get telegram working; bug in telegram-cli with send_text
function send_telegram() {
    # write to temporary mail file
    if [[ -e "$MAIL_FILE" ]]; then
        rm -rf "$MAIL_FILE"
    fi
    
    echo "Last update: $last_upd." >> $MAIL_FILE
    echo "You have $num_pkg updates:"  >> $MAIL_FILE
    echo "mail" "$pkg_list" >> $MAIL_FILE
   
    # send via telegram
    telegram-cli -W -C -D -k ${_telegram_public_key} -e "send ${_telegram_destination} $( cat ${MAIL_FILE} )" 
}

function parse_config() {
    _old_ifs=$IFS
    while IFS= read -r line; do
        if [[ $line == "#"* ]]; then
            continue
        elif [[ $line == "" || $line == " "* ]]; then
            continue
        fi

        _name="$( echo "${line}" | sed -re 's/=.*$//' )"
        _setting=$( echo "${line}" | sed -re 's/^.*=(\S+)\s.*$/\1/g' )
   
        # check name and setting
        case ${_name} in
            "FORCE_PACMAN")
                case "${_setting}" in
                    "0"|"1")
                        _conf_pacman_forced=${_conf_pacman_forced:-${_setting}} ;;
                    *)
                        exit_option_err ${_name} ${_setting} ;;
                esac ;;
            "OUTPUT")
                case ${_setting} in
                    "cron")
                        _conf_cron_output=${_conf_cron_output:-1} ;;
                    "sendmail")
                        #_conf_mail=0
                        ;;
                    "mail")
                        #_conf_mail=1
                        ;;
                    "nullmailer")
                        #_conf_mail=2
                        ;;
                    "none")
                        _conf_no_mail=${_conf_no_mail:-1} ;;
                    *)
                        exit_option_err ${_name} ${_setting} ;;
                esac ;;
            *)
                echo "ERROR: cannot parse option ${_name}"
                exit 1 ;;
        esac
    done < <(echo "${1}")
    IFS=$_old_ifs
}


# parse command line options
while [[ -n $1 ]]; do
    case ${1} in
        "-h"|"--help")
            print_help
            exit 0 ;;
        "-c"|"--config")
            if [[ -e "${2}" ]]; then
                CONFIG_FILE="${2}"
            else
                print "Can't open config file '${2}'"
                exit 1
            fi
            shift 2 ;;
        "-p")
            _conf_pacman_forced=1
            shift ;;
        "-v")
            _conf_print_list=1
            shift ;;
        "-d")
            _conf_no_mail=1
            shift ;;
        "-q")
            _conf_cron_output=1
            shift ;;
        *)
            echo "Unknown option: $1"
            print_usage
            exit 1 ;;
    esac
done

# get config
if [[ -e "$CONFIG_FILE" ]]; then
    conf="$( cat $CONFIG_FILE )"
    parse_config "$conf"
fi

# set defaults for unset configs
_conf_pacman_forced=${_conf_pacman_forced:-0}
_conf_print_list=${_conf_print_list:-0}
_conf_no_mail=${_conf_no_mail:-0}
_conf_cron_output=${_conf_cron_output:-0}

# create temporary directory if not exists
if [[ ! -d "/var/lib/pun" ]]; then
    mkdir /var/lib/pun
fi

# check for pacman and package-query
if [[ -x "$( which pacman 2> /dev/null )" ]]; then
    _pacman="$( which pacman )"
else
    echo "Error: cannot find pacman. Your system is weird!"
    exit 1
fi

if [[ -x "$( which package-query 2> /dev/null )" && $_conf_pacman_forced != 1 ]]; then
    _query="$( which package-query )"
    list_cmd="$_query -QAu"
else
    list_cmd="$_pacman --color never -Qu"
fi

# update package database
$_pacman -Sy >& /dev/null
if (( $? != 0 )); then
    echo "Error: cannot update database (Maybe no sudo?)"
    exit 1
fi

# get updatelist
pkg_list="$( $list_cmd 2> /dev/null )"
if (( $? != 0 )); then
    echo "Error: cannot fetch update list"
    exit 1
fi

num_pkg="$( echo -e "${pkg_list}" | wc -l )"
last_upd="$( grep -e 'starting full system upgrade' /var/log/pacman.log | sed -re 's/^\[([0-9]{4}-[0-9]{2}-[0-9]{2}\s[0-9]{2}:[0-9]{2})\]\s.*$/\1/g' | tail -n -1 )"

# print message
print_log "Last update: $last_upd"

if (( $num_pkg == 0 )); then
    # system is up to date => don't send a mail
    print_log "System is up to date."
elif (( $_conf_no_mail != 0 )); then
    # dry run, don't send a mail
    if (( $_conf_print_list == 0)); then
        print_log "You have $num_pkg updates."
    else
        print_log "You have $num_pkg updates:"
        print_pkglist "log" "$pkg_list"
    fi
else
    # read last_mail date from file
    if [[ -e "$LAST_MAIL_SAVE" ]]; then
        mail_sec=$( date -d "$( cat "$LAST_MAIL_SAVE" )" +%s )
    fi

    # read package numer of last check from file
    if [[ -e "$LAST_CHECK_SAVE" ]]; then
        last_num="$( cat "$LAST_CHECK_SAVE" )"
    fi

    update_sec=$( date -d "$last_upd" +%s )

    # should we send a mail?
    if (( ${mail_sec:-0} < $update_sec || ${last_num:-0} < $num_pkg )); then
        # mail not yet send OR new updates available
        print_log "You have $num_pkg updates. Sending mail..."
        
        # send mail
        send_mail

        date +"%Y-%m-%d %H:%M" > $LAST_MAIL_SAVE
        echo "$num_pkg" > $LAST_CHECK_SAVE
    else
        # no new updates
        print_log "No new updates since last mail."
    fi
fi

